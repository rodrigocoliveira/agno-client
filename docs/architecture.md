# Architecture Overview

This document describes the internal architecture of the Agno client libraries for developers who want to understand how the packages work, contribute to the codebase, or build custom integrations.

## Package Hierarchy

The monorepo contains three packages with a strict dependency flow:

```
@rodrigocoliveira/agno-types     (no dependencies)
        ^
        |
@rodrigocoliveira/agno-client    (depends on types)
        ^
        |
@rodrigocoliveira/agno-react     (depends on client + types)
```

| Package | Purpose | Entry Point |
|---------|---------|-------------|
| `agno-types` | Shared TypeScript types matching the official Agno API | `packages/types/src/index.ts` |
| `agno-client` | Core stateful client with streaming, sessions, and memory | `packages/core/src/index.ts` |
| `agno-react` | React hooks and context adapter | `packages/react/src/index.ts` |

All packages output both CommonJS and ESM bundles via Bun's built-in bundler, with `.d.ts` declarations generated by `tsc`.

## Core Library Architecture

The core library (`@rodrigocoliveira/agno-client`) uses a modular, event-driven architecture. The `AgnoClient` class extends `eventemitter3` and delegates work to focused manager classes:

```
AgnoClient (EventEmitter)
├── MessageStore      Immutable message state management
├── ConfigManager     Centralized configuration (endpoint, auth, mode, IDs)
├── SessionManager    Fetch/convert session history from API
├── MemoryManager     Memory CRUD operations
├── EventProcessor    Process RunEvent types and update messages
└── StreamParser      Parse incremental JSON from fetch streams
```

### Why EventEmitter?

The `AgnoClient` uses the EventEmitter pattern to provide real-time updates without coupling to any UI framework. This means:

- The core library works in any JavaScript environment (Node.js, browser, React Native)
- UI frameworks subscribe to events and sync to their own state management
- Multiple listeners can observe the same events independently

### Manager Responsibilities

**MessageStore** manages the array of `ChatMessage` objects. All updates are immutable -- it creates new array references on every change so that framework reactivity systems (React, Vue, etc.) can detect changes via reference comparison.

**ConfigManager** centralizes all configuration: endpoint URL, auth tokens, mode (agent/team), entity IDs, user IDs, database IDs, and custom query parameters. It provides getter/setter methods and handles query string building.

**SessionManager** handles session lifecycle: listing sessions, loading session history, and deleting sessions. It converts the API's nested session format (with `message`/`response` structure) to the client's flat `ChatMessage[]` format, and extracts tool calls from `reasoning_messages` when present.

**MemoryManager** handles CRUD operations for the Agno Memory API: creating, listing, updating, and deleting user memories and memory topics.

**EventProcessor** takes raw `RunResponse` chunks from the stream and maps `RunEvent` types to `MessageStore` operations. It handles tool call merging (by `tool_call_id` or `${tool_name}-${created_at}`), reasoning step accumulation, and run lifecycle events.

**StreamParser** handles incremental JSON parsing from fetch streams. This is critical because streaming responses arrive as partial JSON -- standard `JSON.parse()` would fail. The parser:

1. Accumulates partial JSON in a buffer
2. Uses brace-counting to detect complete JSON objects
3. Supports both legacy format (direct `RunResponseContent`) and new format (`event`/`data` structure)
4. Automatically converts the new format to legacy for backward compatibility

## Event and Streaming Flow

When a user sends a message, data flows through the system in this sequence:

```
User calls sendMessage("Hello")
         |
         v
AgnoClient builds FormData (message, session_id, user_id)
         |
         v
StreamParser.streamResponse() opens a fetch stream
         |
         v
StreamParser.parseBuffer() extracts complete JSON objects
         |
         v
EventProcessor.processChunk() maps RunEvent to state changes
         |
         v
MessageStore.updateLastMessage() creates new immutable state
         |
         v
AgnoClient.emit('message:update', messages)
         |
         v
React hooks (or any listener) sync to UI state
```

### Key Events

| Event | Payload | When |
|-------|---------|------|
| `message:update` | `ChatMessage[]` | Message content changes during streaming |
| `message:complete` | `ChatMessage[]` | Streaming run completes |
| `run:started` | `void` | A new run begins |
| `run:paused` | `{ tools }` | Agent pauses for frontend tool execution (HITL) |
| `run:continued` | `void` | Paused run resumes after tool results submitted |
| `state:change` | `ClientState` | Any state property changes |
| `error` | `Error` | An error occurs |

## React Adapter Architecture

The React package (`@rodrigocoliveira/agno-react`) wraps the core client with idiomatic React patterns:

```
<AgnoProvider>                     Creates AgnoClient via useRef
└── AgnoContext                    Provides client instance
    └── useAgnoClient()            Access client directly
        ├── useAgnoChat()          Message management + streaming
        ├── useAgnoSession()       Session loading/management
        ├── useAgnoMemory()        Memory management
        ├── useAgnoActions()       Initialization + helpers
        ├── useAgnoToolExecution() Frontend tool execution (HITL)
        └── useAgnoCustomEvents()  Custom events from AgentOS backend
```

### Design Decisions

**Single client instance.** `AgnoProvider` creates the `AgnoClient` once via `useRef` and persists it across renders. This ensures event subscriptions remain stable and prevents re-initialization on re-renders.

**Event synchronization.** Each hook uses `useEffect` to subscribe to relevant `AgnoClient` events and syncs the data to React state via `useState`. When the component unmounts, the subscription is cleaned up.

**Hook composition.** Each hook has a single responsibility and can be used independently. `useAgnoChat` handles messages, `useAgnoSession` handles session history, etc. This lets consumers import only what they need.

## Type System

Types in `@rodrigocoliveira/agno-types` are organized by domain:

| File | Contents |
|------|----------|
| `events.ts` | `RunEvent` enum and client event types |
| `messages.ts` | `ChatMessage`, `ToolCall`, `ReasoningStep`, media types |
| `api.ts` | API response types: `RunResponse`, `SessionEntry`, `AgentDetails`, `UserMemory`, etc. |
| `config.ts` | Configuration and state types |

All types match the official Agno API specification. `RunEvent` values use PascalCase (e.g., `'RunStarted'`, `'RunPaused'`) to match the API exactly.

## Key Implementation Details

### Tool Call Processing

Tool calls can arrive in two formats from the API:

- **New format:** a single `tool` object per chunk
- **Legacy format:** an array of `tools`

The `EventProcessor` normalizes both formats and merges tool calls by `tool_call_id`. If no ID is present, it falls back to `${tool_name}-${created_at}` as a unique identifier. This correctly handles updates to the same tool call across multiple streaming chunks.

### Frontend Tool Execution (HITL)

The library supports Human-in-the-Loop frontend tool execution for agents (not teams). The flow is:

1. Agent encounters a tool with `external_execution=True`
2. Backend emits `RunPaused` event with tools awaiting execution
3. Core client updates state and emits `run:paused`
4. `useAgnoToolExecution` hook (or custom listener) executes tool handlers
5. Results are sent back via `client.continueRun(toolResults)`
6. Backend emits `RunContinued` and resumes processing

See [Frontend Tool Execution](./frontend-tools.md) for usage details.

### Session Conversion

The Agno API returns session history in a nested format with `message`/`response` pairs. The `SessionManager` flattens this into a `ChatMessage[]` array suitable for rendering. It also extracts tool calls from `reasoning_messages` if present in the response data.

### Immutable State

All state updates in `MessageStore` create new array/object references. This is deliberate -- it enables React's shallow comparison to detect changes and trigger re-renders, and prevents accidental mutation bugs.

## Build System

All packages use Bun's built-in bundler:

- **Output formats:** CommonJS (`.cjs`) and ESM (`.mjs`)
- **Type declarations:** Generated by `tsc` (not bundled)
- **Build order:** `types` -> `core` -> `react` (enforced by workspace dependencies)
- **Workspace protocol:** Packages reference each other via `workspace:*`

Run `bun run build` from the root to build all packages in the correct order.
